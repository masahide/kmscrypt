package kmscrypt

import (
	"testing"

	"github.com/aws/aws-sdk-go/aws"
	"github.com/aws/aws-sdk-go/service/kms"
	"github.com/aws/aws-sdk-go/service/kms/kmsiface"
)

func TestAesEncryptDecrypt(t *testing.T) {
	cases := []struct {
		resp kms.GenerateDataKeyOutput
		data string
	}{
		{
			resp: kms.GenerateDataKeyOutput{
				CiphertextBlob: []byte{
					0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0xcc, 0x53, 0xd5, 0xdb, 0x00, 0xdd, 0x87, 0x90,
					0x00, 0x00, 0x00, 0x00, 0x5d, 0x00, 0x00, 0x00, 0xa5, 0xc2, 0xfd, 0x6a, 0x00, 0xcc, 0x5b, 0x2c,
					0x00, 0x00, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x30, 0xed, 0x11, 0x04, 0x00, 0x67, 0x59, 0x85,
					0x00, 0x00, 0x00, 0x00, 0x98, 0x00, 0x00, 0x00, 0x02, 0x3b, 0x01, 0x10, 0x00, 0x2a, 0xc0, 0xe4,
					0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0xed, 0x2f, 0x0b, 0xe7, 0x00, 0x56, 0xa4, 0x04,
					0x00, 0x00, 0x00, 0x00, 0x86, 0x00, 0x00, 0x00, 0x6f, 0x01, 0x30, 0x6d, 0x00, 0x00, 0x30, 0x68,
					0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x01, 0x1e, 0x07, 0x01, 0x00, 0x06, 0x09, 0x60,
					0x00, 0x00, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x00, 0xd0, 0xbf, 0xa9, 0xf3, 0x00, 0x63, 0x1e, 0x8c,
					0x00, 0x00, 0x00, 0x00, 0xfa, 0x00, 0x00, 0x00, 0x00, 0x06, 0x7e, 0x30, 0x00, 0x09, 0x2a, 0x86,
					0x00, 0x00, 0x00, 0x00, 0x8f, 0x00, 0x00, 0x00, 0x2b, 0x13, 0x5f, 0x87, 0x00, 0x02, 0x02, 0x0f,
					0x00, 0x00, 0x00, 0x00, 0xd0, 0x00, 0x00, 0x00, 0x94, 0x06, 0x89, 0x96, 0x00, 0xc5, 0x6e, 0xba,
					0x00, 0x00, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00,
				}, // 184byte
				KeyId:     aws.String("arn:aws:kms:ap-northeast-1:00000000:key/1111111-1111-1111-111111111"),
				Plaintext: []byte("01234566890123456689012345668901"), // 32byte

			},
			data: "flkadjflksdjflaskfjlaskdjfaeiugywe98guasdgfjhasfdasfjasjdfoakjfdlkajdfoaiefhgiudhvuyasdtf7f3g48r723ighs65vr2749rujfosdhvaufh283rt8iufhjaosfjoHIOFHJDIFHE9fh93RHIUDHH7R651HGHDDHF",
		},
	}

	for i, c := range cases {
		mock := mockedKMS{resp: c.resp}
		res, err := AESEncrypt(&mock, *c.resp.KeyId, "keyname", c.data)
		if err != nil {
			t.Fatalf("%d, unexpected error:%s", i, err)
		}
		//pp.Println(res, len(res))
		decrypt, err := AESDecrypt(&mock, "keyname", res)
		if err != nil {
			t.Fatalf("%d, unexpected error:%s", i, err)
		}
		if decrypt != c.data {
			t.Errorf("%d, decrypt:err  got %q, expected:%q", i, decrypt, c.data)
		}
	}
}

type mockedKMS struct {
	kmsiface.KMSAPI
	resp kms.GenerateDataKeyOutput
}

func (m mockedKMS) GenerateDataKey(in *kms.GenerateDataKeyInput) (*kms.GenerateDataKeyOutput, error) {
	// Only need to return mocked response output
	res := m.resp
	res.Plaintext = make([]byte, len(m.resp.Plaintext))
	copy(res.Plaintext, m.resp.Plaintext)
	return &res, nil
}
func (m mockedKMS) Decrypt(in *kms.DecryptInput) (*kms.DecryptOutput, error) {
	// Only need to return mocked response output
	decResp := kms.DecryptOutput{KeyId: m.resp.KeyId, Plaintext: make([]byte, len(m.resp.Plaintext))}
	copy(decResp.Plaintext, m.resp.Plaintext)
	return &decResp, nil
}
